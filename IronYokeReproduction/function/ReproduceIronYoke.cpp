
#include"../src/include.hpp"
using namespace std;

void ReproduceIronYoke(string ifn_AxisymmetrizedFieldMap, string ofn_root, string ofn_dat){
  //read axisymmetrized field map which is generated with 3d-OPERA map
  Bs B_target;
  B_target.Read2dFieldMap(ifn_AxisymmetrizedFieldMap);
  cout<<"MFEP number: "<<B_target.MFEPs()<<endl;

  //set solenoid coil at Tsukuba
  cb Coil;
  Coil.SetTsukubaSolenoid();

  //calculate target magnetic field by subtract B_coil from B_all
  B_target.subtract(Coil);

  //discritize inner surface of iron yoke as evenly spaced dots
  double pitch = ArrangedPitch_FilamentLoopCoil;
  int pitch_mm = pitch * 1.e3;
  string FileName_yoke_config = "IronYoke_" + to_string(pitch_mm) + "mm.dat";
  string path_to_iron_yoke_config_file = "../../data/" + FileName_yoke_config;
  CreateIronYokeGeometry(ArrangedPitch_FilamentLoopCoil, FileName_yoke_config);

  //set filament loop coils at the dots
  cb IronYoke;
  IronYoke.read_rz(path_to_iron_yoke_config_file);
  int n_FLC_yoke = IronYoke.coil_vec().size();
  cout << "FLC number: " << n_FLC_yoke << endl;

  //calculate FLC currents so that they reproduce target field generated by iron yoke
  IronYoke.optimize(TruncatedEigenmodeNumber, B_target, "|B|");
  
  //check if max current density on iron yoke exceeds saturated current density for iron
  vector<double> cd_list;//list of current density
  for(coil coil:IronYoke.coil_vec()){
    cd_list.push_back(coil.I()/pitch);//[A/m]
  } 
  double max_cd = *max_element(cd_list.begin(), cd_list.end());
  cout << "max of reproduced current density: " << max_cd << " A/m" << endl;
  if(magnetization_iron < max_cd){
    cout << "It exceeds saturation current density for iron!" << endl;
    cout << "Truncated eigenmode number " << TruncatedEigenmodeNumber;
    cout << " may be too big" << endl;
  }

  //evaluate accuracy of reproduction
  Bs B_error = B_target;
  B_error.subtract(IronYoke);
  double min_B_error=B_error.min('z');
  double max_B_error=B_error.max('z');
  double p2p = max_B_error - min_B_error;
  cout << "accuracy of reproduction: " << p2p*1.e4 << " Gauss" << endl;
  cout<<"minimum of error Bz :"<<min_B_error*1.e4<<" Gauss"<<endl;
  cout<<"maximum of error Bz :"<<max_B_error*1.e4<<" Gauss"<<endl;

  //draw some magnetic field distributions
  auto c = new TCanvas("c", "c");
  DrawMagneticField_TsukubaSolenoid(IronYoke,Coil, c, ifn_AxisymmetrizedFieldMap);
  auto fout = new TFile(ofn_root.c_str(), "recreate");
  c->Write();
  fout->Close();
  
  //write current distribution to file
  IronYoke.out(ofn_dat);
}
