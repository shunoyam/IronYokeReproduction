
#include"../src/include.hpp"
using namespace std;

void ReproduceIronYoke(string path_to_ConfigurationFile,
                       string path_to_IronYokeParameter,
                       string path_to_CoilInformation,
                       string ifn_3dOPERAMap,
                       string ofn_root,
                       string ofn_dat){

  //load global variables from configuration file
  LoadConfigurationFile(path_to_ConfigurationFile);
  // defined at IronYokeReproduction/function/LoadConfigurationFile.cpp

  
  //axisymmetrize 3d OPERA map and generate dat file
  string FileName_AxisymmetrizedMap = "AxisymmetrizedFieldMap.dat";
  Axisymmetrize3dOperaMap(ifn_3dOPERAMap, FileName_AxisymmetrizedMap);
  // defined at IronYokeReproduction/function/Axisymmetrize3dOperaMap.cpp
  

  //read axisymmetrized field map which is generated with .table file
  string path_to_AxisymmetrizedMap = "../../data/" + FileName_AxisymmetrizedMap;
  Bs B_target(path_to_AxisymmetrizedMap);


  //set solenoid coil at Tsukuba (mini solenoid)
  CoilBlocks TsukubaMiniSolenoid(path_to_CoilInformation);
  //defined at IronYokeReproduction/src/class/coils/coils.cpp
  cout << TsukubaMiniSolenoid.B(TVector3(.1, .2, .3)).z() << endl;
  return;

  //calculate target magnetic field by subtract B_coil from B_all
  B_target.subtract(TsukubaMiniSolenoid);


  //discritize inner surface of iron yoke as evenly spaced dots
  double pitch = pitch_CircularCurrentLoopsOnIronYoke;
  int pitch_um = pitch * 1.e6;
  string FileName_DiscritizedIronYoke = "IronYoke_" + to_string(pitch_um) + ".dat";
  CreateIronYokeGeometry(path_to_IronYokeParameter, FileName_DiscritizedIronYoke);
  // defined at IronYokeReproduction/function/CreateIronYokeGeometry.cpp


  //set circular current loops at the dots
  coils IronYoke;
  string path_to_DiscritizedIronYoke = "../../data/" + FileName_DiscritizedIronYoke;
  IronYoke.read_rz(path_to_DiscritizedIronYoke);
  cout << IronYoke.coil_vec().size();
  cout << " filament loop coils are arranged on iron yoke." << endl;


  //calculate FLC currents so that they reproduce target field generated by iron yoke
  IronYoke.optimize(TruncatedEigenmodeNumber, B_target, "|B|");
  puts("calculation done");
  //defined at IronYokeReproduction/src/class/coils/coils.cpp
  

  //check if max current density on iron yoke exceeds saturated current density for iron
  vector<double> cd_list;//list of current density
  for(coil coil:IronYoke.coil_vec()){
    cd_list.push_back(coil.I()/pitch);//[A/m]
  } 
  double max_cd = *max_element(cd_list.begin(), cd_list.end());
  cout << "max of reproduced current density: " << max_cd << " A/m" << endl;
  if(magnetization_iron < max_cd){
    cout << "It exceeds saturation current density for iron!" << endl;
    cout << "Truncated eigenmode number " << TruncatedEigenmodeNumber;
    cout << " may be too large" << endl;
  }


  //evaluate accuracy of reproduction
  Bs B_error = B_target;
  B_error.subtract(IronYoke);
  double error_max = B_error.max("|B|");//max of absolute value
  cout << "accuracy of reproduction: " << error_max*1.e4 << " Gauss" << endl;


  //draw some magnetic field distributions
  auto c = new TCanvas("c", "c");
  DrawMagneticField_TsukubaSolenoid(IronYoke, TsukubaMiniSolenoid,
                                    c, path_to_AxisymmetrizedMap);


  //defined below
  auto fout = new TFile(ofn_root.c_str(), "recreate");
  c->Write();
  fout->Close();
  

  //write current distribution to file
  IronYoke.out(ofn_dat);

}


void study20230515(){

  LoadConfigurationFile("../../data/configuration.txt");
  TVector3 mfep(5.11, 5.214, 5.4154);
  CoilBlocks cbs("../../data/test.txt");

  coils c1;
  double r_outer = .2;
  double r_inner = .1;
  double center_r = (r_outer+r_inner) / 2.;
  double HalfWidth_r = (r_outer-r_inner) / 2.;
  int node = NodeNumberForGaussianQuadrature;
  double HalfWidth_z = .1;
  c1.SetOnGaussNodes(center_r, HalfWidth_r, node, 0., HalfWidth_z, node, 1.e6);
  cout << c1.B(mfep).z() << " vs " << cbs.B(mfep).z() << endl;  
}















