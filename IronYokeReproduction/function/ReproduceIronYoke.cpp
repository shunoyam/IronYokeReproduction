
#include"../src/include.hpp"
using namespace std;

void ReproduceIronYoke(string ifn_3dOPERAMap, string ofn_root, string ofn_dat){

  //axisymmetrize 3d OPERA map and generate dat file
  string FileName_AxisymmetrizedMap = "AxisymmetrizedFieldMap.dat";
  Axisymmetrize3dOperaMap(ifn_3dOPERAMap, FileName_AxisymmetrizedMap);
  

  //read axisymmetrized field map which is generated with 3d-OPERA map
  Bs B_target;
  B_target.Read2dFieldMap(FileName_AxisymmetrizedMap);
  cout<<"MFEP number: "<<B_target.MFEPs()<<endl;


  //set solenoid coil at Tsukuba
  cb Coil;
  Coil.SetTsukubaSolenoid();
  cout << "bz near origin: " << Coil.B(TVector3(.01, .0, .01)).z()*1.e4 << " Gauss" << endl;


  //calculate target magnetic field by subtract B_coil from B_all
  B_target.subtract(Coil);


  //discritize inner surface of iron yoke as evenly spaced dots
  double pitch = ArrangedPitch_FilamentLoopCoil;
  int pitch_mm = pitch * 1.e3;
  string FileName_yoke_config = "IronYoke_" + to_string(pitch_mm) + "mm.dat";
  string path_to_iron_yoke_config_file = "../../data/" + FileName_yoke_config;
  CreateIronYokeGeometry(ArrangedPitch_FilamentLoopCoil, FileName_yoke_config);


  //set filament loop coils at the dots
  cb IronYoke;
  IronYoke.read_rz(path_to_iron_yoke_config_file);
  cout << "FLC number: " << IronYoke.coil_vec().size() << endl;


  //calculate FLC currents so that they reproduce target field generated by iron yoke
  IronYoke.optimize(TruncatedEigenmodeNumber, B_target, "|B|");
  

  //check if max current density on iron yoke exceeds saturated current density for iron
  vector<double> cd_list;//list of current density
  for(coil coil:IronYoke.coil_vec()){
    cd_list.push_back(coil.I()/pitch);//[A/m]
  } 
  double max_cd = *max_element(cd_list.begin(), cd_list.end());
  cout << "max of reproduced current density: " << max_cd << " A/m" << endl;
  if(magnetization_iron < max_cd){
    cout << "It exceeds saturation current density for iron!" << endl;
    cout << "Truncated eigenmode number " << TruncatedEigenmodeNumber;
    cout << " may be too big" << endl;
  }


  //evaluate accuracy of reproduction
  Bs B_error = B_target;
  B_error.subtract(IronYoke);
  double error_max = B_error.max("|B|");//max of absolute value
  cout << "accuracy of reproduction: " << error_max*1.e4 << " Gauss" << endl;


  //draw some magnetic field distributions
  cout << "bz near origin: " << Coil.B(TVector3(.01, .0, .01)).z()*1.e4 << " Gauss" << endl;
  auto c = new TCanvas("c", "c");
  DrawMagneticField_TsukubaSolenoid(IronYoke, Coil, c, FileName_AxisymmetrizedMap);
  auto fout = new TFile(ofn_root.c_str(), "recreate");
  c->Write();
  fout->Close();
  

  //write current distribution to file
  IronYoke.out(ofn_dat);

}
